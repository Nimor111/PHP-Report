<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1, user-scalable=no" />
    <title>Index</title>

    <link rel="stylesheet" href="css/bootstrap.min.css">
    <script src="javascript/jquery.min.js"></script>
    <script src="javascript/bootstrap.min.js"></script>

    <link rel="stylesheet" href="css/styles.css" type="text/css" media="screen" charset="utf-8">

  </head>
  <body data-spy="scroll" data-target="#myScrollspy" data-offset="20">
    <div>
      <p class="header">PHP 7 - The Good Stuff</p> </div>
    <div class="container">
      <div class="row">
        <div class="features">
          <div class="features-content" id="myScrollspy">
            <button class="features-btn">PHP7 Features</button>
            <nav id="myScrollspy">
              <ul class="nav nav-pills nav-stacked">
                <li class="active"><a href="#intro">Въведение</a></li>
                <li><a href="#speed">Бързина</a></li>
                <li><a href="#ast">Синтактично дърво</a></li>
                <li><a href="#new-ops">Нови оператори</a></li>
                <li><a href="#types">Типови декларации</a></li>
                <li><a href="#">RNG</a></li>
                <li><a href="#">Грешки</a></li>
                <li><a href="#">Анонимни класове</a></li>
                <li><a href="#">Инварианти</a></li>
                <li><a href="#resources">Ресурси</a></li>
          </div>
        </div>
        <div class="logo">
          <img src="img/php-logo.png"/>
          <h3 id="intro">Въведение</h3>
        </div>
        <p class="paragraph">
          PHP 7 е нова и чакана дълго време голяма версия на езика за програмиране PHP и представлява революция в начина, по който уеб приложенията се програмират и доставят като мобилни, бизнес и облачни такива. Версията е смятана като най-важната промяна в PHP след версия 5 на езика през 2004.<br />
          PHP 7 използва новия <a href="https://en.wikipedia.org/wiki/Zend_Engine">Zend Engine</a> 3.0 и подобрява бързината на приложения почти два пъти в сравнение на PHP 5.6 (последната версия на PHP 5). Новата версия на езика е адаптирана към модерните изисквания за работа на уеб приложения.
          Основните подобрения и добавки в езика са:
          <ul class="paragraph">
            <li>Бързина - два пъти по-бърз в сравнение с PHP 5.6</li>
            <li>Значително намалено количество използвана памет</li>
            <li>Абстрактно синтактично дърво</li>
            <li>Консистентна поддръжка за 64-битови типови</li>
            <li>Подобрена йерархия от грешки</li>
            <li>Много фатални грешки превърнати в грешки ( Exceptions )</li>
            <li>Безопасен генератор на случайни числа</li>
            <li>Премахнати стари и неподдържани SAPI ( Server API )</li>
            <li>Скаларни типови декларации за аргументи на функции и върнатите им типове</li>
            <li>Анонимни класове</li>
            <li>Инварианти с нулева цена ( Zero-cost assertions )</li>
          </ul>
        </p>
        <div class="logo">
          <h3 id="speed">Бързина</h3>
        </div>
        <p class="paragraph">Основният фокус на PHP 7 е да оптимизира структурата, която представлява променлива в PHP - Zend value (zvals). В PHP 7 zvals не се алокират в heap-a и не съдържат повече брой референции. Вместо това броят референции се съдържа в по-сложната структура, към която сочи zval - низ, масив или обект.
          Фактът, че прости стойности не се алокират в heap-a в PHP 7 премахва нуждата за броене на референции, което само по себе си резултира в подобрено бързодействие. Държането на броя референции в самите стойности също им позволява да бъдат споделяни независимо от zval структурата, коeто е още едно предимство на новата версия на езика спрямо PHP 7. </p>

        <p class="paragraph">Ето една графика, която сравнява заявки към API в PHP 5 и PHP 7.
          Това са резултати от заявки за писане и четене към API. Виждаме, че при 50/50% четещи и пишещи операции, 100% пишещи и 100% четящи операции PHP 7 е по-бърз.</p>
        <div class="perf-graph">
          <img src="img/speed.png"/>
        </div>
        <div class="logo">
          <h3 id="ast">Синтактично дърво (AST)</h3>
        </div>
        <p class="paragraph">
          Една от добавките в PHP 7 е синтактично дърво като част от процеса на интерпретиране на езика. Това помага на интерпретатора на езика да получава повече информация за кода, който сме написали и дава възможности за дефиниране на повече и по-сложни синтактични конструкции.</p>
        <p class="paragraph">Сорс кодът на PHP 7 минава през следните фази:</p>
        <ul class="paragraph">
          <li>Разбиване на токени ( Tokenising ) - сорс код като <pre>function foobar(int $a)</pre> се разбива на парчета (токени), т.е. function, foobar, (, int, $a, ), {, return, 1, +, $a, ; и }. Tokeniser-a също закача за всеки токен някакви допълнителни данни (metadata), които например за foobar казват, че е идентификатор, а function e ключова дума и също така прави трансформации върху низове.</li>
            <li>Разбор (parsing) - интерпретаторът преглежда токените един по един и съпоставя образци, които формират различни структури от езика, рекурсивно построявайки синтактично дърво. Декларация на функция например може да бъде позната по ключовата дума function, име, отваряща скоба, списък от параметри, затваряща скоба, отваряща фигурна скоба, списък от твърдения (statement) и затваряща фигурна скоба. Подобно, списък от аргументи включва опциална типова декларация, име на променлива и евентуално още подобни, разделени със запетаи. В примера от по-горе изразът 1 + $a ще е разпознат като бинарна операция с аргументи 1 и $a. Тази опция се разпознава като аргумент на return, който пък се разпознава като единственото твърдение (statement) в тялото на функцията. int $a пък се разпознава като декларация на параметър на функцията с име $a и тип int. Резултатът от този етап на интерпретацията е нещо подобно: <pre> {
     type: 'function_decl',
     name: 'foobar',
     params: {
         type: 'function_param_list',
         children: [
             {
                 type: 'parameter',
                 name: 'a',
                 typehint: 'int'
             }
         ]
     }
     body: {
         type: 'statement_list',
         children: [
             {
                 type: 'return_statement',
                 expression: {
                     type: 'add',
                     op1: {
                         type: 'integer',
                         value: 1
                     },
                     op2: {
                         type: 'variable',
                         name: 'a'
                     }
                 }
             }
         ]
     }
}
              </pre>
            </li>
            <li>Компилация: Абстрактното синтактично дърво се трансформира в линеен списък от опкодове (opcodes), които виртуалната машина изпълнява. Те са много прости инструкции, които могат да се изпълняват последователно. Така се интерпретира кодът в PHP 7. </li>
        </ul>
        <p class="paragraph">Какво променя PHP 7? В PHP 5 синтактично дърво няма и втората и третата стъпка са обединени - PHP, от списъка с токени, веднага генерира опкодове щом разпознае някоя структура на езика. Това причинява проблеми, когато няма достатъчно информация в списъка от токени - единственото, което може да се направи тук е да се гледат предхождащите токени, за да се генерират операции. Много структури на езика, например Python-style list comprehensions (код от вида [$foo * 2 foreach ($foos as $foo)]), не могат да бъдат имплементирани със стария parser. Тук невъзможността идва от това, че трябва да генерираме опкодовете за foreach първо, тъй като не може да се ползва $foo преди да бъде инициализирано. С новия parser реда на анализиране и компилиране на кода не е от значение и това е възможно.</p>
        <div class="logo">
          <h3 id="new-ops">Нови оператори</h3>
        </div>
        <p class="paragraph">В PHP 7 има следните нови оператори: </p>
        <ul class="paragraph">
          <li>Spaceship operator или комбиниран оператор за сравнение - нотацията на новия оператор изглежда така: <=> (като опростен космически кораб, ако си го представим правилно). Spaceship операторът е бинарен - връща 0 ако аргументите му са равни, 1 ако левия е по-голям, -1 ако десния е по-голям. Нарича се също така тристранен оператор за сравнение и съществува вече в други езици като Perl и Ruby. Сравненията се извършват според стандартните правила за сравнение в PHP. Ето пример за действието му: </li><br />
          <img src="img/spaceship.jpg" />
          <br /><br />
          <li>Другият оператор се нарича Null Coalescing Operator и е много полезна добавка към езика. Той се означава с ?? и е синтактична захар за честите случаи, в които се използват заедно тернарен оператор и функцията isset() за проверка дали даден ключ е наличен в асоциативен масив и съответното му достъпване.  Операторът връща първия си аргумент ако той не е NULL иначе връща втория си аргумент, който играе ролята на стойност по подразбиране за оператора. Този оператор може също така да се прилага във верига за няколко поредни достъпвания на ключове. Няколко примера за използването му: </li><br />
          <pre>
// Взима стойността на $_GET['user'] и връща 'nobody'
// ако ключът не съществува.
$username = $_GET['user'] ?? 'nobody';
// Това е еквивалентно на:
$username = isset($_GET['user']) ? $_GET['user'] : 'nobody';

// Операторът може да бъде прилаган верижно: този код ще върне
// първата дефинирана стойност сред $_GET['user'], $_POST['user'] и 'nobody'.
$username = $_GET['user'] ?? $_POST['user'] ?? 'nobody';
          </pre>
        </ul>
        <div class="logo">
          <h3 id="types">Типови декларации</h3>
        </div>
        <p class="paragraph">
          Типовите декларации позволяват на фунцкии да изискват аргументите си да имат определен тип по време на извикване на програмата. Ако дадена стойност е от неправилния тип се генерира грешка. В PHP 5 тя е фатална грешка, от която можем да се възстановим. В PHP 7 ще бъде хвърлена грешка от вид TypeError. За да се специфицира типова декларация името на типа трябва да бъде сложено преди името на аргумента. Декларацията може да приема NULL стойности ако стойността по подразбиране на аргумента е NULL. Следват валидните типове, от които може да се изисква да е даден параметър и описание на тези типове.
          <table class="table">
            <tr>
              <th>Тип</th>
              <th>Описание</th>
            </tr>
            <tr>
              <td>Име на клас/интерфейс</td>
              <td>Параметърът трябва да е инстанция на дадения клас или интерфейс (операторът instanceof да връща истина за него.)</td>
            </tr>
            <tr>
              <td>Self</td>
              <td>Параметърът трябва да е инстанция на същия клас, на който дефинираме метод. Този тип може да се използва само за клас и методи на инстанции.</td>
            </tr>
            <tr>
              <td>Array</td>
              <td>Параметърът трябва да е <a href="http://php.net/manual/en/language.types.array.php">масив</a>.</td>
            </tr>
            <tr>
              <td>Callable</td>
              <td>Параметърът трябва да <a href="http://php.net/manual/en/language.types.callable.php">може да бъде извикан</a>.</td>
            </tr>
            <tr>
              <td>Bool</td>
              <td>Параметърът трябва да е от <a href="http://php.net/manual/en/language.types.boolean.php">булев</a> тип.</td>
            </tr>
            <tr>
              <td>Float</td>
              <td>Параметърът трябва да е от тип <a href="http://php.net/manual/en/language.types.float.php">рационално число</a>.</td>
            </tr>
            <tr>
              <td>Int</td>
              <td>Параметърът трябва да е от тип <a href="http://php.net/manual/en/language.types.integer.php">цяло число</a>.</td>
            </tr>
            <tr>
              <td>String</td>
              <td>Параметърът трябва да е от тип <a href="http://php.net/manual/en/language.types.string.php">символен низ</a>.</td>
            </tr>
            <tr>
              <td>Iterable</td>
              <td>Параметърът трябва да е от тип iterable (да може да се итерира смислено върху него - или е масив или е инстанция на вградения клас Traversable).</td>
            </tr>
            <tr>
              <td>Object</td>
              <td>Параметърът трябва да е обект.</td>
            </tr>
          </table>
        </p>
        <div class="logo">
          <h3 id="resources">Ресурси</h3>
        </div>
        <h3 class="resources">Списък от ресурси: </h3>
        <ul class="resources-menu">
          <li>[1] PHP documentation - PHP 7 New features
            <a href="http://php.net/manual/en/migration70.new-features.php">
              Link
            </a>
          </li>
          <li>[2] Treehouse blog post - 5 new features in PHP 7
            <a href="https://blog.teamtreehouse.com/5-new-features-php-7">
              Link
            </a>
          </li>
          <li>[3] Tutorials point - PHP 7 tutorial
            <a href="https://www.tutorialspoint.com/php7/php7_introduction.htm">
              Link
            </a>
          </li>
          <li>[4] PHP 7 vs. PHP 5 - A performance comparison
            <a href="https://www.aerospike.com/blog/php7_php5/">
              Link
            </a>
          </li>
          <li>[5] New AST in PHP 7
            <a href="https://www.reddit.com/r/PHP/comments/3vxqu0/eli5_new_ast_in_php_7/">Link</a>
          </li>
          <li>[6] PHP documentation - PHP 7 New features
            <a href="http://php.net/manual/en/migration70.new-features.php">
              Link
            </a>
          </li>

        </ul>
      </div>
    </div>
  </body>
</html>
